***********************************************************************************************************
Rest Prozesse
***********************************************************************************************************

Nachholen:
- Übung scheduling
- FIFO und Round Robin (6.2 a & b) sind freiwillig
- zuerst scheduling-strategien im glatz nachholen
- dann mit musterlösung vergleichen (wichtig, kommt so an prüfung)



Beispiel zum Bestimmen des Schedulings mit einfacher Fifo-Chain (siehe http://edu.panter.ch/OsProzesse/SlidesScheduling/030%20Beispielszenario):
Time    Ready-Queue     CPU
20      B               A
30      B, C            A
40      C               B
90      C, A            B
130     A               C
...

-> in doc ergänzen







***********************************************************************************************************
Peripherie
***********************************************************************************************************
- Peripherie ist alles, das am Bus hängt und nicht CPU oder Speicher ist
- Frage: Wie spricht man mit Peripherie?
- Antwort: 3 Wege:
    - Programmgesteuert:
        - Immer wieder lesen, bis etwas ins Statusregister geschrieben wurde
        - Polling / Busy waiting
        - Nachteil: Blockiert ganzes System
    - Mit Programmunterbrechung (Interrupt):
        - Interrupt:
            - Unterbrechungssignal für CPU - hat höchste Priorität überhaupt (CPU stopt sofort und behandelt Interrupt)
            - Interrupt-Check ist fest in der CPU verdrahtet
            - CPU-Loop muss also ergänzt werden:
                - Fetch (Instruktion holen)
                - Execute (Instruktion ausführen)
                - Interrupt Check
                    - Wenn Interrupt gesendet wurde:
                        - Spring zu entsprechender Adresse (z.B. Interrupt5)
                        - Führe aus, worauf an dieser Adresse verwiesen wird (ISR)
                        - Wenn fertig, führe nächsten CPU-Cycle aus
            - Treten mehrere Interrups gleichzeitig auf: Chain
            - Für Interrupts wird ein Stack verwendet
        - Peripherie hat Controller drin, der mit Ereignissen umgehen kann
        - Ablauf:
            1. Konfigurationsphase (wann er was machen soll) (geht sehr schnell, ms-Bereich)
            2. Controller übernimmt Übertragung des Signals (etwas langsamer, höherer ms-Bereich), z.B. Zeichen übertragen (während dieser Zeit kann CPU etwas anderes machen)
            3. Signalisation (Interrupt), z.B. "habe Zeichen erhalten"
            4. CPU reagiert auf Interrupt (mit ISR, Interrupt Service Routine), sendet z.B. neues Zeichen
        - Software-Interrupt: z.B. wenn von user-mode zu kernel-mode gewechselt werden soll
    - Direct Memory Access (DMA):
        - CPU ist nicht mehr Benötigt für Übertragung von Hauptspeicher zu Peripherie
        - DMA sorgt dafür, dass Peripherie und Hauptspeicher direkt kommunizieren können
        - Ablauf:
            1. Konfiguration (Quelle, Ziel, Menge)
            2. DMA Betrieb (CPU kann derweil etwas anderes machen)
            3. Abschluss (Info, obs funktioniert hat, so und soviel wurde übertragen) -> Wiederum mit Interrupt signalisiert
        - Verwendet für grosse Datenmenge. Haben die Daten nur die Grösse von ein paar Registern, wird Interrupt verwendet
        - Achtung: Während DMA-Prozess ist BUS blockiert, d.h. CPU muss unterbrechen, sobald sie Bus braucht


TODO: Übung Kernel Modul:
    - http://edu.panter.ch/OsEinAusgabe/UebungEigenenLinuxTreiberSchreiben
    - http://tldp.org/LDP/lkmpg/2.6/lkmpg.pdf
    - add note in wiki (about http://tldp.org/LDP/lkmpg/2.6/lkmpg.pdf)
