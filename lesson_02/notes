***********************************************************************************************************
Prozesse
***********************************************************************************************************


Mehrere Prozesse:
- Wir befinden uns in der OS-Welt, nicht mehr in der Hardware-Welt
- Automatische Prozessumschaltung vom Betriebssystem
- PCB (Program Control Block) -> gesamter Zustand eines Programms zu einem bestimmten Zeitpunkt (gespeichert, damit Prozess wieder fortgeführt werden kann nach Prozessumschaltung)
- Wechseln des Prozesses:
    - Prozess A stoppen
    - Zustand Prozess A speichern
    - Zustand Prozess B laden
    - Prozess B ausführen
- Auch Betriebssystem braucht Prozess(e)


Ausführbare Datei:
- Programmcode (Logik)
- Infos Speicherbelegung (z.B. für Konstanten)
- Initialwerte (für Variablen / Konstanten)
- Ausführung:
    - Programm laden (Programm in RAM laden)
    - Initialisierung (Speicher allozieren, Initialwerte besetzen, Prozesse aufsetzten)
    - Starten (Programm-Counter auf 1. Instruktion setzen)
    - Programmablauf (Konkurrierung mit anderen Prozessen)
    - Bendigung (Return-Wert, Speicherfreigabe, PCB löschen)

Prozesse starten:
- Verkettung (chain): Nacheinander
- Vergabelung (fork): Duplizierung und auf unterschiedliche Weise fortfahren
- Erzeugung (create): Völlig neuen Prozess erstellen, momentaner Prozess existiert weiter
- Unix kann nur fork und chain
- Prozesse vereinigen: join/exit
- Befehle:
    - exec() für chain
    - fork() für fork (Rückgabewert sagt, ob man child (0) ist, oder parent (prozess-ID, pid von parent))
    - wait() um auf anderen Prozess zu warten
    - exit() um Prozess zu beenden
- Beispiel für fork:
    - Webserver
    - Wartet auf Port 80
    - Port 80 soll aber nicht für neue Anfragen blockiert werden
    -> Lösung: Parent-Prozess, der auf neue Anfragen hört. Child-Prozess pro Anfrage
- Zombieprozess:
    - Wenn der Parent-Prozess wait() aufruft, der entsprechende Child-Prozess aber schon exit() aufgerufen hat -> Eltern-Prozess wartet ewig
    - Oder: Wenn Parent-Prozess Child-Prozess erstellt und sich dann beendet -> Child-Prozess kann niemandem returnen (Waise-Prozess), kann aber noch weiterlaufen


Scheduling:
- Prozesse sind oft am warten -> Problem im quasiparallelen System, denn dann ver(sch)wenden die Prozesse ihren Rechenanteil ja zum Warten
- Deshalb: Scheduling
- Prozesse können im Scheduling 4 Zustände haben: Waiting, Running, Ready, Inactive
- Verdrängendes Scheduling: Betriebssystem zwingt Prozess zu stoppen -> "von laufend nach bereit" oder "von inaktiv nach bereit"
- Fifo: Einfache Fifo-Chain, nächster Prozess startet, wenn erster wartet (es wird aber nicht verdrängt)
- RoundRobin: Alle 40 (Beispiel) Zeiteinheiten wird Prozess gewechselt (Verdrängende Strategie), oder natütlich, wenn er eh fertig ist
- LevelPriority: Priorisierung der Prozesse untereinander. Sobald ein Prozess wartet, kommt der höchstpriorisierte Wartende dran 
- MLV-Chain (Multi Level Feedback): Ähnlich wie LevelPriority, allerdings wird "Aushungern" der tief priorisierten Prozesse verhindert, indem hochpriorisierte Prozesse nach langer Laufzeit nach und nach runterpriorisiert werden (so machen es moderne Betriebssysteme)


Beispiel zum Bestimmen des Schedulings mit einfacher Fifo-Chain (siehe http://edu.panter.ch/OsProzesse/SlidesScheduling/030%20Beispielszenario):
Time    Ready-Queue     CPU
20      B               A
30      B, C            A
40      C               B
90      C, A            B
130     A               C
...



